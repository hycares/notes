# 进程间通信

IPC发展

```
UNIX IPC ---> SystemV IPC
						---> Linux IPC
		---> Socket IPC   
```

常见的IPC

>1. 管道
>2. 信号
>3. 信号量
>4. 消息队列
>5. 共享内存
>6. 套接字

### 管道技术

管道技术是从UNIX上继承发展的，其特点是半双工（单向流动）【但有全双工的实现】，具有固定的读写端（两个 `fd` ）。在Linux系统中一切皆文件，管道可以看作是一种特殊的文件，可以通过 `read / write` 系统调用进行读写，但是文件并不存在于文件系统中，只在内存中，类似（`/proc`）。

管道分为两种类型，具名管道（`fifo`）和匿名管道（`pipe`），两种管道的操作与实现基本一致，都是通过**内核缓冲区**（这意味着数据存在用户态和内核态的拷贝）进行数据传输，但是建立等操作并不相同。

#### PIPE

`pipe` 的使用必须是存在亲缘关系的进程中，比如父子，兄弟进程即存在公共祖先的进程。通过`pipe(int fd[2])`系统调用创建并打开，`fd[0]`为读端，`fd[1]`为写端。

管道的读写是阻塞的，当`read`的写端为关闭状态时，所有数据都读完则返回0。当`write`的读端关闭时则产生`SIGPIPE`信号。

```bash
$ echo 'pipe' | more   # | 代表的是一个匿名管道，二者能够通信是因为都是shell创建的子进程
```

```c
#include <unistd.h>

int main(int argc, char const *argv[])
{
  int fd[2];
  pid_t pid;
  char line[1024];

  pipe(fd);
  pid = fork();

  if (pid > 0) { // parent
    write(fd[1], "this is parent pipe write port\n", 32);
    close(fd[0]);
  } else { // child
    int n = read(fd[0], line, 1024);
    write(STDOUT_FILENO, line, n);
    close(fd[1]);
  }

  return 0;
}
```

##### pipe的相关操作函数

- `popen`
- `pclose`

#### FIFO

`fifo`和`pipe`的主要区别在于，具名管道的名字对应于一个磁盘索引节点，通过这个文件名，**任何具备权限的进程**都可以对它进行访问。

`fifo`的主要用途有两个：

- 通过`shell`命令数据从一条管道传输到另一条时，不需要临时中间文件，和`pipe`的区别在于，可以线性连接多个进程。
- 在类C/S模型下，`fifo`作为汇聚点，在客户端和服务器进程间传递数据。

```bash
$ mkfifo fifo1  # 文件类型是 p (pipe)
$ echo 'test' > fifo1  # 数据传输到fifo，并且默认阻塞
$ less < fifo1  # 从fifo中读取数据后，上一个进程会才结束阻塞

# 输入过滤 线性串联
$ prog1 < fifo1
$ filter < process_file | tee fifo1 | prog2 # tee和fifo 将一个流转发到两个不同的进程，可以通过多个tee和fifo来串接。
```

##### fifo的相关操作函数

- `mkfifo`
- `mkfifoat`

#### 管道总结

管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区读写数据，等价于一个环形对列，默认情况下，当数据写进管道没有读取时会被阻塞，同理读未关闭的空管道也会阻塞，一旦有数据出现就会解除阻塞。可以设置`O_NONBLCOK`成为非阻塞管道。

